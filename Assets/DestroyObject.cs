using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
//Script taken from here: https://gist.github.com/ditzel/73f4d1c9028cc3477bb921974f84ed56#file-meshdestroy-cs
//Video referenced by it here: https://www.youtube.com/watch?v=VwGiwDLQ40A
//Go through this and document it from educational purposes
//Then see if you can optimize it
//CRIT: Var is used too much. Replace with correct type definations
public class DestroyObject : MonoBehaviour
{
    private bool edgeSet = false;
    private Vector3 edgeVertex = Vector3.zero;
    private Vector2 edgeUV = Vector2.zero;
    private Plane edgePlane = new Plane();
    private Vector3 explodeCenter;
    private static List<PartMesh> meshManager;
    private const int maxPieaces = 25;
    public int CutCascades = 1;
    public float ExplodeForce = 0;

    // Start is called before the first frame update
    void Start()
    {
        if(meshManager == null)
        {
            meshManager = new List<PartMesh>();
        }
    }

    // Update is called once per frame
   /*
    void Update()
    {
        if (Input.GetMouseButtonDown(0))
        {
            Ray r = Camera.main.ScreenPointToRay(Input.mousePosition);
            RaycastHit hit;
            Physics.Raycast(r, out hit, 100f);
            if (hit.collider.gameObject != null && hit.collider.gameObject.Equals(this.gameObject))
            {
                explodeCenter = this.gameObject.transform.position;
                DestroyMesh();
            }
            
        }
    }
    */
    public void DestroyMesh()
    {
        //Unparent object to avoid issues
        this.transform.SetParent(null);
        explodeCenter = this.gameObject.transform.position;
        //Setup variables for submeshes
        var originalMesh = GetComponent<MeshFilter>().mesh;
        originalMesh.RecalculateBounds();
        var parts = new List<PartMesh>();
        var subParts = new List<PartMesh>();
        //Copy current info from mesh to mainPart var
        var mainPart = new PartMesh()
        {
            UV = originalMesh.uv,
            Vertices = originalMesh.vertices,
            Normals = originalMesh.normals,
            Triangles = new int[originalMesh.subMeshCount][],
            Bounds = originalMesh.bounds
        };
        for (int i = 0; i < originalMesh.subMeshCount; i++)
            mainPart.Triangles[i] = originalMesh.GetTriangles(i);
        //Add the original mesh as a part called main part
        parts.Add(mainPart);
        //For each cut, go through the parts and cut the mesh into two pieaces
        //as defined by a plane
        for (var c = 0; c < CutCascades; c++)
        {
            for (var i = 0; i < parts.Count; i++)
            {
                var bounds = parts[i].Bounds;
                bounds.Expand(0.5f);
                //Plane with random oriantation
                var plane = new Plane(UnityEngine.Random.onUnitSphere, new Vector3(UnityEngine.Random.Range(bounds.min.x + bounds.extents.x / 2f, bounds.max.x - bounds.extents.x / 2f),
                                                                                   UnityEngine.Random.Range(bounds.min.y + bounds.extents.y / 2f, bounds.max.y - bounds.extents.y / 2f),
                                                                                   UnityEngine.Random.Range(bounds.min.z+bounds.extents.z/2f, bounds.max.z - bounds.extents.z / 2f)));

                //Generate meshes for the left and right sides of the cut
                subParts.Add(GenerateMesh(parts[i], plane, true));
                subParts.Add(GenerateMesh(parts[i], plane, false));
            }
            //Copy the new subparts to our parts list
            //subParts contains the current amount of subPieaces, and will replace parts
            parts = new List<PartMesh>(subParts);
            
            //Clear out the subparts generated by the cuts
            subParts.Clear();
        }
        
        //Attempts to calculate the direction and force to push the parts with
        Vector3 explodeDir;
        for (var i = 0; i < parts.Count; i++)
        {
            parts[i].MakeGameobject(this);
            //Figure out center of the submesh
            parts[i].avgCenter = Vector3.zero;
            Vector3[] verts = parts[i].GameObject.GetComponent<MeshFilter>().mesh.vertices;
            for(int j = 0; j < verts.Length;j++)
            {
                parts[i].avgCenter += verts[j];
            }
            parts[i].avgCenter /= parts[i].Vertices.Length;
            parts[i].avgCenter = this.gameObject.transform.TransformPoint(parts[i].avgCenter);
            explodeDir = parts[i].avgCenter - explodeCenter;//new Vector3(UnityEngine.Random.Range(-1f,1f),0, UnityEngine.Random.Range(-1f, 1f));
            Debug.Log(explodeDir.normalized);
            //explodeDir.y = 0;
            parts[i].GameObject.GetComponent<Rigidbody>().AddForceAtPosition(explodeDir.normalized * ExplodeForce, transform.position);
        }
        //Parts contains all the sub pieaces after these loops are done
        //Add parts to manager so we can delete if there are too many
        //OPT: Ideally delete before going through above loop. Figure out solution later
        //IDEA: Have list be list of references. Figure out how to do that in C#
        meshManager.AddRange(parts);
        if (meshManager.Count > maxPieaces)
        {
            int removeCount = meshManager.Count - maxPieaces;
            for (int i = 0; i < removeCount; i++)
            {
                //Remove the oldest elements in the queue
                Destroy(meshManager[0].GameObject);
                meshManager.RemoveAt(0);
            }
        }

        //Destory the original object since it techinally shouldnt exist
        Destroy(gameObject);
    }
    //Handles the creatation of new submeshs made from cut
    private PartMesh GenerateMesh(PartMesh original, Plane plane, bool left)
    {
        var partMesh = new PartMesh() { };
        var ray1 = new Ray();
        var ray2 = new Ray();

        //We are going though the submeshes in the base mesh
        for (var i = 0; i < original.Triangles.Length; i++)
        {
            //Get the triangles from the submesh
            var triangles = original.Triangles[i];
            edgeSet = false;
            //Going through the triangles in the mesh
            for (var j = 0; j < triangles.Length; j = j + 3)
            {
                //Determine which side the vertices are relative to the plane
                var sideA = plane.GetSide(original.Vertices[triangles[j]]) == left;
                var sideB = plane.GetSide(original.Vertices[triangles[j + 1]]) == left;
                var sideC = plane.GetSide(original.Vertices[triangles[j + 2]]) == left;
                //Collapse this into a single variable to make flow control easier
                var sideCount = (sideA ? 1 : 0) +
                                (sideB ? 1 : 0) +
                                (sideC ? 1 : 0);
                //if all vertices are on the right of the plane, do othing
                if (sideCount == 0)
                {
                    continue;
                } //if they are all on the left, add the whole triangle
                if (sideCount == 3)
                {
                    partMesh.AddTriangle(i,
                                         original.Vertices[triangles[j]], original.Vertices[triangles[j + 1]], original.Vertices[triangles[j + 2]],
                                         original.Normals[triangles[j]], original.Normals[triangles[j + 1]], original.Normals[triangles[j + 2]],
                                         original.UV[triangles[j]], original.UV[triangles[j + 1]], original.UV[triangles[j + 2]]);
                    continue;
                }
                //else, if we have a mixed set of left and right vertices
                //Use raycasting to calculate new points for a potential triangle
                //cut points
                var singleIndex = sideB == sideC ? 0 : sideA == sideC ? 1 : 2;
                //Shoot a ray to the next vertex and return the distance to that point
                //We are useing the raycast to the plane to determine the intersection
                ray1.origin = original.Vertices[triangles[j + singleIndex]];
                var dir1 = original.Vertices[triangles[j + ((singleIndex + 1) % 3)]] - original.Vertices[triangles[j + singleIndex]];
                ray1.direction = dir1;
                plane.Raycast(ray1, out var enter1);
                var lerp1 = enter1 / dir1.magnitude;
                //Shoot a ray to the next vertex and return the distance to that point
                //We are useing the raycast to the plane to determine the intersection
                ray2.origin = original.Vertices[triangles[j + singleIndex]];
                var dir2 = original.Vertices[triangles[j + ((singleIndex + 2) % 3)]] - original.Vertices[triangles[j + singleIndex]];
                ray2.direction = dir2;
                plane.Raycast(ray2, out var enter2);
                var lerp2 = enter2 / dir2.magnitude;

                //first vertex = ancor (singleIndex stores first vertex)
                //Add an edge of the triangle to the mesh. Adjust normal if on left side
                //Use distance from raycast (lerps specifically) to get all the other info
                //(Vertex positons and UVs in this case)
                AddEdge(i,
                        partMesh,
                        left ? plane.normal * -1f : plane.normal,
                        ray1.origin + ray1.direction.normalized * enter1,
                        ray2.origin + ray2.direction.normalized * enter2,
                        Vector2.Lerp(original.UV[triangles[j + singleIndex]], original.UV[triangles[j + ((singleIndex + 1) % 3)]], lerp1),
                        Vector2.Lerp(original.UV[triangles[j + singleIndex]], original.UV[triangles[j + ((singleIndex + 2) % 3)]], lerp2));
                //if only 1 point is on the left side, add the triangle created by our raycasts
                if (sideCount == 1)
                {
                    partMesh.AddTriangle(i,
                                        original.Vertices[triangles[j + singleIndex]],
                                        //Vector3.Lerp(originalMesh.vertices[triangles[j + singleIndex]], originalMesh.vertices[triangles[j + ((singleIndex + 1) % 3)]], lerp1),
                                        //Vector3.Lerp(originalMesh.vertices[triangles[j + singleIndex]], originalMesh.vertices[triangles[j + ((singleIndex + 2) % 3)]], lerp2),
                                        ray1.origin + ray1.direction.normalized * enter1,
                                        ray2.origin + ray2.direction.normalized * enter2,
                                        original.Normals[triangles[j + singleIndex]],
                                        Vector3.Lerp(original.Normals[triangles[j + singleIndex]], original.Normals[triangles[j + ((singleIndex + 1) % 3)]], lerp1),
                                        Vector3.Lerp(original.Normals[triangles[j + singleIndex]], original.Normals[triangles[j + ((singleIndex + 2) % 3)]], lerp2),
                                        original.UV[triangles[j + singleIndex]],
                                        Vector2.Lerp(original.UV[triangles[j + singleIndex]], original.UV[triangles[j + ((singleIndex + 1) % 3)]], lerp1),
                                        Vector2.Lerp(original.UV[triangles[j + singleIndex]], original.UV[triangles[j + ((singleIndex + 2) % 3)]], lerp2));

                    continue;
                }
                //If two points are on the left, add the two triangles created by the raycasts
                if (sideCount == 2)
                {
                    partMesh.AddTriangle(i,
                                        ray1.origin + ray1.direction.normalized * enter1,
                                        original.Vertices[triangles[j + ((singleIndex + 1) % 3)]],
                                        original.Vertices[triangles[j + ((singleIndex + 2) % 3)]],
                                        Vector3.Lerp(original.Normals[triangles[j + singleIndex]], original.Normals[triangles[j + ((singleIndex + 1) % 3)]], lerp1),
                                        original.Normals[triangles[j + ((singleIndex + 1) % 3)]],
                                        original.Normals[triangles[j + ((singleIndex + 2) % 3)]],
                                        Vector2.Lerp(original.UV[triangles[j + singleIndex]], original.UV[triangles[j + ((singleIndex + 1) % 3)]], lerp1),
                                        original.UV[triangles[j + ((singleIndex + 1) % 3)]],
                                        original.UV[triangles[j + ((singleIndex + 2) % 3)]]);
                    partMesh.AddTriangle(i,
                                        ray1.origin + ray1.direction.normalized * enter1,
                                        original.Vertices[triangles[j + ((singleIndex + 2) % 3)]],
                                        ray2.origin + ray2.direction.normalized * enter2,
                                        Vector3.Lerp(original.Normals[triangles[j + singleIndex]], original.Normals[triangles[j + ((singleIndex + 1) % 3)]], lerp1),
                                        original.Normals[triangles[j + ((singleIndex + 2) % 3)]],
                                        Vector3.Lerp(original.Normals[triangles[j + singleIndex]], original.Normals[triangles[j + ((singleIndex + 2) % 3)]], lerp2),
                                        Vector2.Lerp(original.UV[triangles[j + singleIndex]], original.UV[triangles[j + ((singleIndex + 1) % 3)]], lerp1),
                                        original.UV[triangles[j + ((singleIndex + 2) % 3)]],
                                        Vector2.Lerp(original.UV[triangles[j + singleIndex]], original.UV[triangles[j + ((singleIndex + 2) % 3)]], lerp2));
                    continue;
                }


            }
        }
        //Submit the triangle info we added during the above process
        partMesh.FillArrays();

        return partMesh;
    }
    //Add an edge for a triangle to the submesh
    private void AddEdge(int subMesh, PartMesh partMesh, Vector3 normal, Vector3 vertex1, Vector3 vertex2, Vector2 uv1, Vector2 uv2)
    {
        //Setup the edge set if not setup already
        if (!edgeSet)
        {
            edgeSet = true;
            edgeVertex = vertex1;
            edgeUV = uv1;
        }
        else
        {
            //Create a plane using the provided info and the last edge vertex
            edgePlane.Set3Points(edgeVertex, vertex1, vertex2);
            //Create an incomplete triangle
            partMesh.AddTriangle(subMesh,
                                edgeVertex,
                                edgePlane.GetSide(edgeVertex + normal) ? vertex1 : vertex2,
                                edgePlane.GetSide(edgeVertex + normal) ? vertex2 : vertex1,
                                normal,
                                normal,
                                normal,
                                edgeUV,
                                uv1,
                                uv2);
        }
    }

    //Class to handle the creation of submeshes 
    public class PartMesh
    {
        //CRIT: This system has a lot of redundant vertices. Should be optimized at some point
        private List<Vector3> _Verticies = new List<Vector3>(); //Vertices inheirated from original
        private List<Vector3> _Normals = new List<Vector3>(); //Normals inheirated from original
        private List<List<int>> _Triangles = new List<List<int>>(); //Triangles added with addTriangle
        private List<Vector2> _UVs = new List<Vector2>(); //UVs from original
        public Vector3[] Vertices; //Vertices of the mesh (Contains all of the verts from the original!)
        public Vector3[] Normals; //Normals of the mesh
        public int[][] Triangles; //Triangle windings
        public Vector2[] UV; //UVs for mesh
        public GameObject GameObject; //Gameobject housing mesh
        public Bounds Bounds = new Bounds(); //Bounds of the mesh
        public Vector3 avgCenter; //The center of the mesh calculated by getting the average

        public PartMesh()
        {

        }
        //Find the submesh and add the provided infomation about the triangle to the submesh
        public void AddTriangle(int submesh, Vector3 vert1, Vector3 vert2, Vector3 vert3, Vector3 normal1, Vector3 normal2, Vector3 normal3, Vector2 uv1, Vector2 uv2, Vector2 uv3)
        {
            if (_Triangles.Count - 1 < submesh)
                _Triangles.Add(new List<int>());
            //Sets the vertices and indices for the trianlge for submesh index submesh
            _Triangles[submesh].Add(_Verticies.Count);
            _Verticies.Add(vert1);
            _Triangles[submesh].Add(_Verticies.Count);
            _Verticies.Add(vert2);
            _Triangles[submesh].Add(_Verticies.Count);
            _Verticies.Add(vert3);
            _Normals.Add(normal1);
            _Normals.Add(normal2);
            _Normals.Add(normal3);
            _UVs.Add(uv1);
            _UVs.Add(uv2);
            _UVs.Add(uv3);
            //Determines mesh bounds with new vertices
            Bounds.min = Vector3.Min(Bounds.min, vert1);
            Bounds.min = Vector3.Min(Bounds.min, vert2);
            Bounds.min = Vector3.Min(Bounds.min, vert3);
            Bounds.max = Vector3.Min(Bounds.max, vert1);
            Bounds.max = Vector3.Min(Bounds.max, vert2);
            Bounds.max = Vector3.Min(Bounds.max, vert3);
        }
        //Copy data from the private arrays to the public ones
        public void FillArrays()
        {
            Vertices = _Verticies.ToArray();
            Normals = _Normals.ToArray();
            UV = _UVs.ToArray();
            Triangles = new int[_Triangles.Count][];
            for (var i = 0; i < _Triangles.Count; i++)
                Triangles[i] = _Triangles[i].ToArray();
        }

        public void MakeGameobject(DestroyObject original)
        {
            //Inherit the transform values of the game object
            GameObject = new GameObject(original.name);
            GameObject.transform.position = original.transform.position;
            GameObject.transform.rotation = original.transform.rotation;
            GameObject.transform.localScale = original.transform.localScale;
            //Create an empty mesh
            var mesh = new Mesh();
            mesh.name = original.GetComponent<MeshFilter>().mesh.name;
            //Calculating avgCenter
            /*
            Vector3 avg = new Vector3(0, 0, 0);
            if (Vertices.Length < 1)
            {
                Destroy(GameObject);
                return;
            }
            //CRIT: Should be replaced with system to only pick
            //vertices used in triangles
            //Currently uses ALL vertices!
            
            foreach(Vector3 v in Vertices)
            {
                avg += v; 
            }
            //CRIT: Not transformed into world space! FIX IT
            avg /= Vertices.Length;
            avgCenter = avg;
            */
            //Populate empty mesh with inherited nesh info
            mesh.vertices = Vertices;
            mesh.normals = Normals;
            mesh.uv = UV;
            //Provides triangles to each of the submeshes
            for (var i = 0; i < Triangles.Length; i++)
                mesh.SetTriangles(Triangles[i], i, true);
            Bounds = mesh.bounds;

            var renderer = GameObject.AddComponent<MeshRenderer>();
            renderer.materials = original.GetComponent<MeshRenderer>().materials;

            var filter = GameObject.AddComponent<MeshFilter>();
            filter.mesh = mesh;

            var collider = GameObject.AddComponent<MeshCollider>();
            collider.convex = true;

            var rigidbody = GameObject.AddComponent<Rigidbody>();
            //var meshDestroy = GameObject.AddComponent<DestroyObject>();
            //meshDestroy.CutCascades = original.CutCascades;
            //meshDestroy.ExplodeForce = original.ExplodeForce;

        }

    }
}
